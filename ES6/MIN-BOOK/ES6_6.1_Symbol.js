// Спецификация ES вводит новые объектные интерфейсы и способы выполнения итераций.
// Добавление новых итерационных протоколов открывает новый мир алгортимов и возможностей для JavaScript

// СИМВОЛЫ В СПЕЦИФИКАЦИИ ES6
{
/**
 символы это новый элементраный тип. Символы являются уникальными и неизменными значениями
*/
  var s = Symbol();

  /**
   Функция Symbol() принимает необязательный строковый параметр с описанием символа.
   Описания символов можно использовать при отладке, но они не имеют доступа к самому символу.
   Два символа с тем же описанием не равны друг другу
   например
     let s1 = window.Symbol("My Symbol");
     let s2 = window.Symbol("My Symbol");
     console.log(s1 === s2); // выведит false
   */

//  Единственная возможность определить что переменная содержит символ */
    var s = Symbol();
    console.log(typeof s); // выведит Symbol

//  Использование символов как ключей свойств
/**
 В спецификации ES5 и ранних версиях в роли ключей выступали строки.
 Но в спецификации ES6 ключи свойств объектов могут быть как строки так и символы
 пример
 */
    let obj = null;
    let s1 = null;
    (function(){
      let s2 = Symbol();
      s1 = s2;
      obj = {[s2]:"mySymbol"}
      console.log(obj[s2]);  // mySymbol
      console.log(obj[s2] == obj[s1]); // true
    })
    /**
     Как можно заметить в этом примере при получении ключа свойства, заданного символом, он должен быть заключен в квадратные скобки [].
     Для доступа к символьному ключу свойства необходим символ.
     Переменный s1 и s2 хранят один и тот же символ
     */
    console.log(obj[s1]); // mySymbol
    // [] - в этих скобках вычисляется значение
    // Основной причиной введения символов в спецификацию ES6 было стремление использовать их в качестве ключей для свойств объектов, чтобы предотвратить случайный конфликт ключей свойств


  // МЕТОД Object.getOwnPropertySymbols()
  /**
   * Метод Oblect.getOwnPropertyNames() не может извлекать символьные свойства поэтому был введен Object.getOwnPropertySymbols()
   */
  {
   let obj = {a:12};
   let s1 = Symbol("mySymbol");
   let s2 = Symbol("mySymbol");
    Object.defineProperty(obj, s1, {
      enumerable: false
    });
    obj[s2] = "";
    console.log(object.getOwnPropertySymbols(obj));
    // результат Symbol(mySymbol), Symbol(mySymbol)
    /**
     * Из примера видно что метод Object.getOwnPropertySymbols() МОЖЕТ извлекать и неперечисляемые символьные свойства
     // опереатор in обнаруживает симовльные свойства объекта, в то время как цикл for...in и метод Object.getOwnPropertyNames() - нет, для поддержания обратной совместимости
     */
  }

  {
    // МЕТОД Symbol.for(string)
    /**
     Объект Symbol введет регистрацию пар ключ/значение, где ключом является описание символа, а значением сам символ.
     Всякий раз, когда вызовом Symbol.for() создается символ, он добавляется в реестр и метод возвращает символ.
     Если попытаться создать символ с описанием, которое уже существует, бедет извлечен существующий символ

     Приемущества Symbol.for() в том, что он создает символ глобально
     */
     let obj = {};
     (function(){
       let s1 = Symbol("name");
       obj[s1] = "Eden";
     })();
     // obj[s1]  недоступен здесь
     (function(){
       let s2 = Symbol.for("age");
       obj[s2] = 27;
     })();
     console.log(obj[Symbol.for("age")]); // 27
  }
}
// ПРОТОКОЛЫ ИТЕРАЦИЙ
{

}
